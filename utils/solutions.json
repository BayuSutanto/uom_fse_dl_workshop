{
    "SE01": {
        "exercise_1": {
            "answers": {
                "scalar_tensor": {
                    "value": 42,
                    "dtype": "torch.int64"
                },
                "float_tensor": {
                    "value": 3.14,
                    "dtype": "torch.float32"
                }
            },
            "hints": [
                "Remember to use torch.tensor() and specify dtype=torch.float32 for the float tensor",
                "The scalar tensor should be created with just the value 42"
            ]
        },
        "exercise_2": {
            "answers": {
                "random_tensor": {
                    "shape": [3, 3],
                    "dtype": "torch.int64",
                    "min_val": 1,
                    "max_val": 10
                },
                "identity_matrix": {
                    "shape": [3, 3],
                    "dtype": "torch.float32",
                    "diagonal": 1.0
                },
                "spaced_tensor": {
                    "shape": [5],
                    "dtype": "torch.float32",
                    "min_val": 0.0,
                    "max_val": 1.0
                },
                "zero_tensor": {
                    "shape": [2, 3],
                    "dtype": "torch.float32",
                    "value": 0.0
                }
            },
            "hints": [
                "Use torch.randint() for random integers",
                "Use torch.eye() for identity matrix",
                "Use torch.linspace() for evenly spaced numbers",
                "Use torch.zeros() for zero tensor"
            ]
        },
        "exercise_3": {
            "answers": {
                "position_2_3": {
                    "value": 12,
                    "dtype": "torch.int64"
                },
                "second_row": {
                    "value": [5, 6, 7, 8],
                    "dtype": "torch.int64"
                },
                "last_column": {
                    "value": [4, 8, 12, 16],
                    "dtype": "torch.int64"
                },
                "bottom_right": {
                    "value": [[11, 12], [15, 16]],
                    "dtype": "torch.int64"
                },
                "even_elements": {
                    "value": [2, 4],
                    "dtype": "torch.int64"
                },
                "all_corners": {
                    "value": [[1, 4], [13, 16]],
                    "dtype": "torch.int64"
                },
                "middle_block": {
                    "value": [[6, 7], [10, 11]],
                    "dtype": "torch.int64"
                }
            },
            "hints": [
                "Use index [2,3] for position_2_3",
                "Use index [1,:] for second row",
                "Use index [:,3] for last column",
                "Use index [2:,2:] for bottom right",
                "Use index [0,1::2] for even elements",
                "Use [...,[0,-1]] for corners",
                "Use [1:3,1:3] for middle block"
            ]
        },
        "exercise_4": {
            "answers": {
                "addition": {
                    "value": [[6, 8], [10, 12]],
                    "dtype": "torch.int64"
                },
                "multiplication": {
                    "value": [[5, 12], [21, 32]],
                    "dtype": "torch.int64"
                },
                "matrix_mult": {
                    "value": [[19, 22], [43, 50]],
                    "dtype": "torch.int64"
                },
                "sqrt_a": {
                    "value": [[1.0, 1.4142], [1.7321, 2.0]],
                    "dtype": "torch.float32"
                }
            },
            "hints": [
                "Use + for addition",
                "Use * for element-wise multiplication",
                "Use @ for matrix multiplication",
                "Use torch.sqrt() and convert to float first"
            ]
        },
        "exercise_5": {
            "answers": {
                "matrix_mult": {
                    "value": [[7, 10], [15, 22]],
                    "dtype": "torch.float32"
                },
                "transpose": {
                    "value": [[1, 3], [2, 4]],
                    "dtype": "torch.float32"
                },
                "determinant": {
                    "value": -2.0,
                    "dtype": "torch.float32"
                },
                "inverse": {
                    "value": [[-2.0, 1.0], [1.5, -0.5]],
                    "dtype": "torch.float32" 
                }
            },
            "hints": [
                "Use @ or matmul() for matrix multiplication",
                "Use .T for transpose",
                "Use torch.det() for determinant",
                "Use torch.inverse() for matrix inverse"
            ]
        },
        "exercise_6": {
            "answers": {
                "broadcast_add": {
                    "value": [[3, 4], [5, 6]],
                    "dtype": "torch.int64"
                },
                "broadcast_mult": {
                    "value": [[2, 4], [6, 8]],
                    "dtype": "torch.int64"
                },
                "row_add": {
                    "value": [[2, 3], [4, 5]],
                    "dtype": "torch.int64"
                },
                "col_mult": {
                    "value": [[2, 4], [9, 12]],
                    "dtype": "torch.int64"
                },
                "batch_scale": {
                    "value": [[[2, 4], [6, 8]], [[10, 12], [14, 16]]],
                    "dtype": "torch.int64"
                }
            },
            "hints": [
                "Scalar broadcasting adds/multiplies the scalar to all elements",
                "Row broadcasting applies operation across columns",
                "Column broadcasting applies operation across rows", 
                "Batch broadcasting applies operation to all batches",
                "Check shapes with .shape after broadcasting"
            ]
        },
        "exercise_7": {
            "answers": {
                "reshaped": {
                    "value": [[1, 2], [3, 4], [5, 6]],
                    "shape": [3, 2],
                    "dtype": "torch.int64"
                },
                "expanded": {
                    "value": [[1], [1], [1]],
                    "shape": [3, 1],
                    "dtype": "torch.float32"
                },
                "broadcast_ready": {
                    "value": [[1], [2], [3]],
                    "shape": [3, 1],
                    "dtype": "torch.int64"
                }
            },
            "hints": [
                "Use reshape(rows, cols) to reshape flat tensor",
                "Use expand() to repeat values without copying",
                "Use reshape(-1, 1) to make column vector",
                "Test broadcasting with a dummy matrix"
            ]
        },
        "exercise_8": {
            "answers": {
                "grad_value": {
                    "value": 39.0,
                    "dtype": "torch.float32"
                },
                "requires_grad": {
                    "value": true
                    }
            },
            "hints": [
                "Set requires_grad=True when creating tensor",
                "Use backward() to compute gradients",
                "Access gradients with .grad attribute",
                "Derivative of y = 3x^3 + 2x^2 - 5x + 1 is dy/dx = 9x^2 + 4x - 5",
                "At x=2: dy/dx = 9(4) + 4(2) - 5 = 36 + 8 - 5 = 39"
            ]
        },
        "exercise_9": {
            "answers": {
                "px_tensor": {
                    "shape": [6000],
                    "dtype": "torch.float64",
                    "column": "Px"
                },
                "py_tensor": {
                    "shape": [6000],
                    "dtype": "torch.float64",
                    "column": "Py"
                },
                "pos_tensor": {
                    "shape": [6000, 3],
                    "dtype": "torch.float64",
                    "columns": ["Px", "Py", "Pz"]
                },
                "all_data": {
                    "shape": [6000, 6],
                    "dtype": "torch.float32"
                }
            },
            "hints": [
                "Use df.column_name.values to get NumPy array",
                "Use torch.tensor() to convert to tensor",
                "Use df[['col1', 'col2']].values for multiple columns",
                "Use .to(device) to move tensor to GPU",
                "Check tensor shapes with .shape attribute"
            ]
        }
    },
    "SE02": {
        "exercise_1": {
            "answers": {
                "sigmoid": {
                    "test_cases": [
                        {"input": [0.0], "expected": 0.5},
                        {"input": [1.0], "expected": 0.7311},
                        {"input": [2.0], "expected": 0.8808},
                        {"input": [-1.0], "expected": 0.2689},
                        {"input": [-2.0], "expected": 0.1192}
                    ],
                    "tolerance": 1e-4
                },
                "neuron_output": {
                    "expected": 0.9241,
                    "tolerance": 1e-4
                }
            },
            "hints": [
                "Sigmoid formula is 1 / (1 + e^(-x))",
                "Use torch.exp(-x) for the exponential",
                "Test with both positive and negative values",
                "Make sure to handle tensor inputs properly"
            ]
        },
        "exercise_2": {
            "answers": {
                "initialized_weights": {
                    "Xavier Uniform": {
                        "std": {
                            "min": 0.15,
                            "max": 0.25
                        }
                    },
                    "Xavier Normal": {
                        "std": {
                            "min": 0.15,
                            "max": 0.25
                        }
                    },
                    "Kaiming Uniform": {
                        "std": {
                            "min": 0.15,
                            "max": 0.25
                        }
                    },
                    "Kaiming Normal": {
                        "std": {
                            "min": 0.15,
                            "max": 0.25
                        }
                    }
                }
            },
            "hints": [
                "Use torch.nn.init functions for initialization",
                "Make sure to create empty tensors before initialization",
                "Check that distributions match theoretical expectations",
                "Xavier/Glorot initialization scales with 1/sqrt(n_in + n_out)",
                "Kaiming initialization scales with 1/sqrt(n_in)"
            ]
        },
        "exercise_3": {
            "answers": {
                "tensors": {
                    "train": {"shape": [6000, 6], "dtype": "torch.float32"},
                    "val": {"shape": [2000, 6], "dtype": "torch.float32"}, 
                    "test": {"shape": [2000, 6], "dtype": "torch.float32"}
                }
            },
            "hints": [
                "Convert DataFrames using .values and torch.tensor()",
                "Specify dtype=torch.float32",
                "Check shapes after conversion"
            ]
        },
        "exercise_4": {
            "answers": {
                "model": {
                    "input_size": 6,
                    "hidden_units": 32,
                    "output_size": 5,
                    "activation": "sigmoid"
                }
            },
            "hints": [
                "Use torch.nn.Linear for layers",
                "Add sigmoid activation between layers",
                "Forward should chain: linear -> sigmoid -> linear",
                "Check layer shapes match specifications"
            ]
        },
        "exercise_5": {
            "answers": {
                "l1_reg": {
                    "lambda": 0.01,
                    "norm_type": "L1",
                    "expected_loss_range": [0.1, 1.0]
                },
                "l2_reg": {
                    "lambda": 0.01,
                    "norm_type": "L2",
                    "expected_loss_range": [0.1, 1.0]
                },
                "dropout": {
                    "rate": 0.2,
                    "training_mode": true
                }
            },
            "hints": [
                "Use model.train() to enable dropout during training",
                "Add L1/L2 regularization terms to the loss function",
                "Experiment with different regularization strengths",
                "Monitor validation loss to prevent overfitting"
            ]
        },
        "exercise_6": {
            "answers": {
                "optimizer_comparison": {
                    "optimizers": ["SGD", "Adam", "RMSprop"],
                    "learning_rate": 0.01,
                    "expected_convergence": true
                }
            },
            "hints": [
                "Compare convergence speed of different optimizers",
                "Plot loss curves to visualize performance",
                "Try different learning rates for each optimizer",
                "Monitor training stability"
            ]
        },
        "exercise_7": {
            "answers": {
                "backprop_check": {
                    "gradients": {
                        "x": {"min": -10.0, "max": 10.0},
                        "y": {"min": -10.0, "max": 10.0}
                    },
                    "requires_grad": true
                }
            },
            "hints": [
                "Enable gradient tracking with requires_grad=True",
                "Use backward() to compute gradients",
                "Check gradient values with .grad attribute",
                "Remember to zero gradients before next backward pass"
            ]
        }
    }
}