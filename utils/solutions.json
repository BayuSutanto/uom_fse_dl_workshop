{
    "documentation": {
        "overview": "Documentation for answer schema: Each session (SE01, SE02, etc.) contains multiple exercises",
        "exercise_structure": [
            "answers: Object containing expected outputs for each part",
            "hints: Array of hints that guide students when they make errors"
        ],
        "schema_conventions": {
            "tensors": {
                "value": "The expected tensor values",
                "dtype": "The expected tensor data type (e.g. torch.float32)",
                "shape": "(Optional) The expected tensor shape",
                "value_range": "(Optional) min_val/max_val for random tensors, acceptable value range"
            },
            "scalar_values": {
                "expected": "The expected numerical value",
                "tolerance": "How much the student's answer can deviate from expected"
            },
            "boolean_checks": {
                "expected": "true/false with the expected outcome",
                "tolerance": "(Optional) For numerical comparison before boolean conversion"
            },
            "function_validation": {
                "test_cases": "Array of input/expected pairs to test the function",
                "tolerance": "How much outputs can deviate from expected values"
            }
        }
    },
    "SE01": {
        "exercise_1": {
            "answers": {
                "scalar_tensor": {
                    "value": 42,
                    "dtype": "torch.int64"
                },
                "float_tensor": {
                    "value": 3.14,
                    "dtype": "torch.float32"
                }
            },
            "hints": [
                "Remember to use torch.tensor() and specify dtype=torch.float32 for the float tensor",
                "The scalar tensor should be created with just the value 42"
            ]
        },
        "exercise_2": {
            "answers": {
                "random_tensor": {
                    "shape": [
                        3,
                        3
                    ],
                    "dtype": "torch.int64",
                    "min_val": 1,
                    "max_val": 10
                },
                "identity_matrix": {
                    "shape": [
                        3,
                        3
                    ],
                    "dtype": "torch.float32",
                    "diagonal": 1.0
                },
                "spaced_tensor": {
                    "shape": [
                        5
                    ],
                    "dtype": "torch.float32",
                    "min_val": 0.0,
                    "max_val": 1.0
                },
                "zero_tensor": {
                    "shape": [
                        2,
                        3
                    ],
                    "dtype": "torch.float32",
                    "value": 0.0
                }
            },
            "hints": [
                "Use torch.randint() for random integers",
                "Use torch.eye() for identity matrix",
                "Use torch.linspace() for evenly spaced numbers",
                "Use torch.zeros() for zero tensor"
            ]
        },
        "exercise_3": {
            "answers": {
                "position_2_3": {
                    "value": 12,
                    "dtype": "torch.int64"
                },
                "second_row": {
                    "value": [
                        5,
                        6,
                        7,
                        8
                    ],
                    "dtype": "torch.int64"
                },
                "last_column": {
                    "value": [
                        4,
                        8,
                        12,
                        16
                    ],
                    "dtype": "torch.int64"
                },
                "bottom_right": {
                    "value": [
                        [
                            11,
                            12
                        ],
                        [
                            15,
                            16
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "even_elements": {
                    "value": [
                        2,
                        4
                    ],
                    "dtype": "torch.int64"
                },
                "all_corners": {
                    "value": [
                        [
                            1,
                            4
                        ],
                        [
                            13,
                            16
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "middle_block": {
                    "value": [
                        [
                            6,
                            7
                        ],
                        [
                            10,
                            11
                        ]
                    ],
                    "dtype": "torch.int64"
                }
            },
            "hints": [
                "Use index [2,3] for position_2_3",
                "Use index [1,:] for second row",
                "Use index [:,3] for last column",
                "Use index [2:,2:] for bottom right",
                "Use index [0,1::2] for even elements",
                "Use [...,[0,-1]] for corners",
                "Use [1:3,1:3] for middle block"
            ]
        },
        "exercise_4": {
            "answers": {
                "addition": {
                    "value": [
                        [
                            6,
                            8
                        ],
                        [
                            10,
                            12
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "multiplication": {
                    "value": [
                        [
                            5,
                            12
                        ],
                        [
                            21,
                            32
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "matrix_mult": {
                    "value": [
                        [
                            19,
                            22
                        ],
                        [
                            43,
                            50
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "sqrt_a": {
                    "value": [
                        [
                            1.0,
                            1.4142
                        ],
                        [
                            1.7321,
                            2.0
                        ]
                    ],
                    "dtype": "torch.float32"
                }
            },
            "hints": [
                "Use + for addition",
                "Use * for element-wise multiplication",
                "Use @ for matrix multiplication",
                "Use torch.sqrt() and convert to float first"
            ]
        },
        "exercise_5": {
            "answers": {
                "matrix_mult": {
                    "value": [
                        [
                            7,
                            10
                        ],
                        [
                            15,
                            22
                        ]
                    ],
                    "dtype": "torch.float32"
                },
                "transpose": {
                    "value": [
                        [
                            1,
                            3
                        ],
                        [
                            2,
                            4
                        ]
                    ],
                    "dtype": "torch.float32"
                },
                "determinant": {
                    "value": -2.0,
                    "dtype": "torch.float32"
                },
                "inverse": {
                    "value": [
                        [
                            -2.0,
                            1.0
                        ],
                        [
                            1.5,
                            -0.5
                        ]
                    ],
                    "dtype": "torch.float32"
                }
            },
            "hints": [
                "Use @ or matmul() for matrix multiplication",
                "Use .T for transpose",
                "Use torch.det() for determinant",
                "Use torch.inverse() for matrix inverse"
            ]
        },
        "exercise_6": {
            "answers": {
                "broadcast_add": {
                    "value": [
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "broadcast_mult": {
                    "value": [
                        [
                            2,
                            4
                        ],
                        [
                            6,
                            8
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "row_add": {
                    "value": [
                        [
                            2,
                            3
                        ],
                        [
                            4,
                            5
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "col_mult": {
                    "value": [
                        [
                            2,
                            4
                        ],
                        [
                            9,
                            12
                        ]
                    ],
                    "dtype": "torch.int64"
                },
                "batch_scale": {
                    "value": [
                        [
                            [
                                2,
                                4
                            ],
                            [
                                6,
                                8
                            ]
                        ],
                        [
                            [
                                10,
                                12
                            ],
                            [
                                14,
                                16
                            ]
                        ]
                    ],
                    "dtype": "torch.int64"
                }
            },
            "hints": [
                "Scalar broadcasting adds/multiplies the scalar to all elements",
                "Row broadcasting applies operation across columns",
                "Column broadcasting applies operation across rows",
                "Batch broadcasting applies operation to all batches",
                "Check shapes with .shape after broadcasting"
            ]
        },
        "exercise_7": {
            "answers": {
                "reshaped": {
                    "value": [
                        [
                            1,
                            2
                        ],
                        [
                            3,
                            4
                        ],
                        [
                            5,
                            6
                        ]
                    ],
                    "shape": [
                        3,
                        2
                    ],
                    "dtype": "torch.int64"
                },
                "expanded": {
                    "value": [
                        [
                            1
                        ],
                        [
                            1
                        ],
                        [
                            1
                        ]
                    ],
                    "shape": [
                        3,
                        1
                    ],
                    "dtype": "torch.float32"
                },
                "broadcast_ready": {
                    "value": [
                        [
                            1
                        ],
                        [
                            2
                        ],
                        [
                            3
                        ]
                    ],
                    "shape": [
                        3,
                        1
                    ],
                    "dtype": "torch.int64"
                }
            },
            "hints": [
                "Use reshape(rows, cols) to reshape flat tensor",
                "Use expand() to repeat values without copying",
                "Use reshape(-1, 1) to make column vector",
                "Test broadcasting with a dummy matrix"
            ]
        },
        "exercise_8": {
            "answers": {
                "grad_value": {
                    "value": 39.0,
                    "dtype": "torch.float32"
                },
                "requires_grad": {
                    "value": true
                }
            },
            "hints": [
                "Set requires_grad=True when creating tensor",
                "Use backward() to compute gradients",
                "Access gradients with .grad attribute",
                "Derivative of y = 3x^3 + 2x^2 - 5x + 1 is dy/dx = 9x^2 + 4x - 5",
                "At x=2: dy/dx = 9(4) + 4(2) - 5 = 36 + 8 - 5 = 39"
            ]
        },
        "exercise_9": {
            "answers": {
                "px_tensor": {
                    "shape": [
                        6000
                    ],
                    "dtype": "torch.float64",
                    "column": "Px"
                },
                "py_tensor": {
                    "shape": [
                        6000
                    ],
                    "dtype": "torch.float64",
                    "column": "Py"
                },
                "pos_tensor": {
                    "shape": [
                        6000,
                        3
                    ],
                    "dtype": "torch.float64",
                    "columns": [
                        "Px",
                        "Py",
                        "Pz"
                    ]
                },
                "all_data": {
                    "shape": [
                        6000,
                        6
                    ],
                    "dtype": "torch.float32"
                }
            },
            "hints": [
                "Use df.column_name.values to get NumPy array",
                "Use torch.tensor() to convert to tensor",
                "Use df[['col1', 'col2']].values for multiple columns",
                "Use .to(device) to move tensor to GPU",
                "Check tensor shapes with .shape attribute"
            ]
        }
    },
    "SE02": {
        "exercise_1": {
            "answers": {
                "sigmoid": {
                    "test_cases": [
                        {
                            "input": [
                                0.0
                            ],
                            "expected": 0.5
                        },
                        {
                            "input": [
                                1.0
                            ],
                            "expected": 0.7311
                        },
                        {
                            "input": [
                                2.0
                            ],
                            "expected": 0.8808
                        },
                        {
                            "input": [
                                -1.0
                            ],
                            "expected": 0.2689
                        },
                        {
                            "input": [
                                -2.0
                            ],
                            "expected": 0.1192
                        }
                    ],
                    "tolerance": 1e-4
                },
                "neuron_input_size": {
                    "expected": 2,
                    "tolerance": 0
                },
                "has_bias": {
                    "expected": true
                },
                "is_parameterized": {
                    "expected": true
                }
            },
            "hints": [
                "The sigmoid function is defined as 1 / (1 + e^(-x))",
                "Use torch.exp(-x) for the exponential part",
                "For the neuron class, remember to use torch.nn.Parameter for weights and bias",
                "The forward method should compute the dot product between weights and input, add bias, then apply activation",
                "For the output test, given input [1.0, 2.0] with weights [1.0, 1.0] and bias 0.5, the result should be close to 0.97",
                "For the neuron class, initialize weights with torch.randn(input_features) to get random values",
                "Make weights and bias learnable by wrapping them with torch.nn.Parameter",
                "Make sure your neuron has the correct number of input features (weights)"
            ]
        },
        "exercise_2": {
            "answers": {
                "f_to_c": {
                    "test_cases": [
                        {
                            "input": [
                                32.0
                            ],
                            "expected": 0.0
                        },
                        {
                            "input": [
                                212.0
                            ],
                            "expected": 100.0
                        },
                        {
                            "input": [
                                68.0
                            ],
                            "expected": 20.0
                        }
                    ],
                    "tolerance": 1e-4
                },
                "X_shape": {
                    "shape": [
                        23,
                        1
                    ],
                    "tolerance": 0
                },
                "y_shape": {
                    "shape": [
                        23,
                        1
                    ],
                    "tolerance": 0
                },
                "X_mean": {
                    "expected": 20.8696,
                    "tolerance": 1e-4
                },
                "X_std": {
                    "expected": 3.9206,
                    "tolerance": 1e-4
                },
                "n_distress_cases": {
                    "expected": 6.0,
                    "tolerance": 0
                },
                "data_clipped": {
                    "expected": true
                },
                "train_test_split_ratio": {
                    "expected": true
                },
                "tensors_created": {
                    "expected": true
                }
            },
            "hints": [
                "The Fahrenheit to Celsius conversion formula is: C = (F - 32) * 5 / 9",
                "Use the clip() method to cap n_distressed values at 1.0",
                "Convert temperature values to PyTorch tensors with .float() and reshape with .view(-1, 1)",
                "Similarly convert n_distressed values and reshape to match temperature shape",
                "Calculate mean with X.mean() and standard deviation with X.std()",
                "Normalize using the formula: (X - X_mean) / X_std",
                "Count distress cases by summing the target tensor with y.sum().item()",
                "Make sure to split the data with approximately 80% for training"
            ]
        },
        "exercise_3": {
            "answers": {
                "mse_loss": {
                    "test_cases": [
                        {
                            "input": [
                                {
                                    "predictions": [
                                        [
                                            0.0
                                        ],
                                        [
                                            0.5
                                        ],
                                        [
                                            1.0
                                        ]
                                    ],
                                    "targets": [
                                        [
                                            0.0
                                        ],
                                        [
                                            0.0
                                        ],
                                        [
                                            1.0
                                        ]
                                    ]
                                }
                            ],
                            "expected": 0.0833
                        },
                        {
                            "input": [
                                {
                                    "predictions": [
                                        [
                                            0.3
                                        ],
                                        [
                                            0.7
                                        ]
                                    ],
                                    "targets": [
                                        [
                                            0.0
                                        ],
                                        [
                                            1.0
                                        ]
                                    ]
                                }
                            ],
                            "expected": 0.0900
                        },
                        {
                            "input": [
                                {
                                    "predictions": [
                                        [
                                            0.0
                                        ],
                                        [
                                            0.0
                                        ]
                                    ],
                                    "targets": [
                                        [
                                            1.0
                                        ],
                                        [
                                            1.0
                                        ]
                                    ]
                                }
                            ],
                            "expected": 1.0
                        }
                    ],
                    "tolerance": 1e-3
                }
            },
            "hints": [
                "Mean Squared Error is calculated as the average of squared differences: mean((predictions - targets)**2)",
                "Use squared_diff = (predictions - targets) ** 2 to calculate the squared differences",
                "Use squared_diff.mean() to get the average",
                "To verify your implementation, compare with PyTorch's nn.MSELoss()",
                "Loop through each input to get predictions from your model",
                "Forward pass: model(X_normalized[i]) for each data point"
            ]
        },
        "exercise_4": {
            "answers": {
                "training_convergence": {
                    "expected": true,
                    "tolerance": 0
                },
                "final_loss": {
                    "max_val": 0.15,
                    "min_val": 0.0
                },
                "negative_weight": {
                    "expected": true,
                    "tolerance": 0
                }
            },
            "hints": [
                "In the backward pass, call loss.backward() to compute gradients",
                "Update parameters using weight -= learning_rate * weight.grad",
                "Remember to zero gradients with weight.grad.zero_() after each update",
                "Use with torch.no_grad(): when updating parameters to prevent tracking computations",
                "For the O-ring data, you should see the weight become negative (indicating higher failure at lower temperatures)",
                "Monitor the loss over time - it should decrease and eventually stabilize"
            ]
        },
        "exercise_5": {
            "answers": {
                "challenger_failure_prob": {
                    "expected": 0.9,
                    "tolerance": 0.15
                },
                "recommendation": {
                    "expected": true
                },
                "relative_risk_factor": {
                    "expected": true
                }
            },
            "hints": [
                "Remember to use the same normalization (subtract X_mean and divide by X_std) for the Challenger temperature",
                "Use model(challenger_tensor) to get the failure probability prediction",
                "The failure probability should be very high (over 0.7) for the cold launch temperature",
                "Compare with a typical 'safe' temperature to see how much higher the risk is",
                "Given the high probability, the recommendation should be to NOT launch",
                "The relative risk should show that failure is many times more likely at the cold launch temperature",
                "Make sure to use with torch.no_grad() when making predictions with a trained model",
                "Normalize the challenger temperature using the same mean and standard deviation as the training data",
                "To calculate relative risk, divide the probability of failure at the challenger temperature by the probability at a normal temperature"
            ]
        },
        "exercise_6": {
            "answers": {
                "test_accuracy": {
                    "expected": 0.8,
                    "tolerance": 0.2
                },
                "test_precision": {
                    "expected": 0.7,
                    "tolerance": 0.3
                },
                "test_recall": {
                    "expected": 0.7,
                    "tolerance": 0.3
                },
                "test_f1": {
                    "expected": 0.7,
                    "tolerance": 0.3
                }
            },
            "hints": [
                "To evaluate on the test set, apply the same prediction process to X_test",
                "Calculate accuracy by comparing binary predictions (threshold 0.5) with actual values",
                "Accuracy is the ratio of correct predictions to total predictions",
                "True positives (TP) are cases where both prediction and actual are 1",
                "False positives (FP) are cases where prediction is 1 but actual is 0",
                "False negatives (FN) are cases where prediction is 0 but actual is 1",
                "Precision = TP / (TP + FP) - what fraction of positive predictions were correct",
                "Recall = TP / (TP + FN) - what fraction of actual positives were correctly identified",
                "F1 score = 2 * (precision * recall) / (precision + recall)",
                "Be careful with division by zero when calculating precision, recall, and F1 score",
                "Use binary_predictions = (test_predictions > 0.5).float() to convert probabilities to binary values",
                "Visualize the test predictions to better understand model performance"
            ]
        }
    },
    "SE03": {
        "exercise_1": {
            "answers": {
                "X_train_tensor": {
                    "dtype": "torch.float32"
                },
                "y_train_tensor": {
                    "dtype": "torch.float32"
                },
                "X_train_scaled": {
                    "min_val": 0.0,
                    "max_val": 1.0,
                    "dtype": "torch.float32"
                },
                "y_train_scaled": {
                    "min_val": 0.0,
                    "max_val": 1.0,
                    "dtype": "torch.float32"
                },
                "scale_range_min": {
                    "expected": 0.0,
                    "tolerance": 0
                },
                "scale_range_max": {
                    "expected":  1.0,
                    "tolerance": 0
                }
            },
            "hints": [
                "Use torch.tensor() to convert the DataFrame values to PyTorch tensors with dtype=torch.float32",
                "Create a CustomScaler with method='minmax' for proper normalization",
                "Remember to fit the scaler on the training data only",
                "Apply the transform method to normalize the data",
                "Check that the normalized data is in the range [0, 1]"
            ]
        },
        "exercise_2": {
            "answers": {
                "model": {
                    "architecture": "Module"
                },
                "input_layer_size": {
                    "expected": 6
                },
                "hidden_layer_size": {
                    "expected": 32
                },
                "output_layer_size": {
                    "expected": 5
                },
                "activation_type": {
                    "expected_type": "ReLU"
                },
                "fc1_weight_stats": {
                    "mean_near_zero": true,
                    "std_range": [0.1, 0.5]
                },
                "fc2_weight_stats": {
                    "mean_near_zero": true,
                    "std_range": [0.1, 0.5]
                },
                "fc1_bias_stats": {
                    "mean_near_zero": true,
                    "std_range": [0.0, 1e-5]
                },
                "fc2_bias_stats": {
                    "mean_near_zero": true,
                    "std_range": [0.0, 1e-5]
                }
            },
            "hints": [
                "Initialize the parent class with super().__init__()",
                "Use torch.nn.Linear for fully connected layers with appropriate input and output sizes",
                "Use torch.nn.ReLU() for the activation function",
                "Use a smaller network (32 hidden neurons) to avoid overfitting",
                "Initialize the first layer weights with torch.nn.init.kaiming_uniform_ which is appropriate for ReLU activations",
                "Use torch.nn.init.xavier_uniform_ for the output layer weights which works well with linear outputs",
                "Initialize all biases to zero with torch.nn.init.zeros_",
                "Kaiming initialization should produce weights with mean near zero and std between 0.1-0.5",
                "Xavier initialization should also have mean near zero but with appropriate variance for the layer size",
                "The final layer should not have an activation function as this is a regression task"
            ]
        },
        "exercise_3": {
            "answers": {
                "optimizer_type": {
                    "expected": true
                },
                "learning_rate": {
                    "expected": 0.001,
                    "tolerance": 1e-6
                },
                "loss_function_type": {
                    "expected": true
                }
            },
            "hints": [
                "Use torch.optim.Adam with params=model.parameters() and lr=0.001",
                "Use torch.nn.MSELoss() for the loss function",
                "Store both optimizer and loss function as attributes of the model for easy access",
                "The learning rate is passed as a parameter to the optimizer"
            ]
        },
        "exercise_4": {
            "answers": {
                "train_losses": {
                    "min_val": 0.0
                },
                "val_losses": {
                    "min_val": 0.0
                },
                "loss_trend": {
                    "expected": true
                },
                "overfit_check": {
                    "expected": true
                }
            },
            "hints": [
                "Call model.train() to put the model in training mode",
                "Zero the gradients with model.optimizer.zero_grad() before each forward pass",
                "Forward pass: compute predictions with model(train_features)",
                "Compute loss with model.loss_function(predictions, train_targets)",
                "Backward pass: compute gradients with loss.backward()",
                "Update weights with model.optimizer.step()",
                "Use model.eval() and torch.no_grad() when computing validation loss"
            ]
        },
        "exercise_5": {
            "answers": {
                "test_loss": {
                    "min_val": 0.0,
                    "max_val": 0.1
                },
                "r2_score": {
                    "min_val": 0.7,
                    "max_val": 1.0
                },
                "predictions_shape": {
                    "expected": true
                },
                "values_match": {
                    "expected": true
                }
            },
            "hints": [
                "Put the model in evaluation mode with model.eval()",
                "Use torch.no_grad() to disable gradient tracking during evaluation",
                "Get predictions with model(X_test_scaled)",
                "Calculate loss with model.loss_function(test_predictions, y_test_scaled)",
                "Use y_scaler.inverse_transform() to convert predictions and targets back to original scale",
                "Calculate R-squared score with utils.ml.r2_score(test_targets_original, test_predictions_original)"
            ]
        },
        "exercise_6": {
            "answers": {
                "improved_model": {
                    "architecture": "Module"
                },
                "num_layers": {
                    "expected": 3
                },
                "has_dropout": {
                    "expected": true
                },
                "has_batch_norm": {
                    "expected": true
                },
                "activation_type": {
                    "expected": true
                }
            },
            "hints": [
                "Initialize the parent class with super().__init__()",
                "Create a more complex architecture with multiple layers",
                "Add batch normalization layers after each linear layer",
                "Use dropout for regularization to prevent overfitting",
                "Use LeakyReLU instead of ReLU for better gradient flow",
                "Remember to follow the correct order: Linear -> BatchNorm -> Activation -> Dropout"
            ]
        }
    }
}